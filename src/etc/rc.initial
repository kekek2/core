#!/bin/sh

# Copyright (c) 2014-2018 Franco Fichtner <franco@opnsense.org>
# Copyright (c) 2004-2011 Scott Ullrich <sullrich@gmail.com>
# Copyright (c) 2003-2004 Manuel Kasper <mk@neon1.net>
# All rights reserved.

# make sure the user can't kill us
trap : 2
trap : 3

# rc.d may call this while being root using `su -m user -c ...'
# and it has arguments to pass through to the shell.  It creates
# a problem for us as su(1) assumes the root shell and has no
# way to override it because the target user most likely does
# not have a shell set.
#
# Worse still, su(1) *is* root, but changes to the selected user ID
# so it creates its own downfall by selecting the root shell to do it.
# On OpenBSD, su(1) does have the `-s' parameter to override the shell.
# FreeBSD has the '-s' parameter as well, but it is completely
# unrelated and the desired functionality does not actually exist.  :(
if [ -n "${*}" ]; then
	/bin/csh "${@}"
	exit ${?}
fi

alias GETTEXT='gettext "OPNsense"'
MENU_0_07=$(GETTEXT "  0) Logout                              7) Ping host")
MENU_1_08=$(GETTEXT "  1) Assign interfaces                   8) Shell")
MENU_2_09=$(GETTEXT "  2) Set interface IP address            9) pfTop")
MENU_3_10=$(GETTEXT "  3) Reset the root password            10) Firewall log")
MENU_4_11=$(GETTEXT "  4) Reset to factory defaults          11) Reload all services")
MENU_5_12=$(GETTEXT "  5) Power off system                   12) Upgrade from console")
MENU_6_13=$(GETTEXT "  6) Reboot system                      13) Restore a backup")
ENTER_AN_OPTION=$(GETTEXT "Enter an option: ")
# Beyond this point the console menu yields no value to scripting,
# so we can check for root to avoid permission errors later on.
if [ "$(id -u)" != "0" ]; then
	echo "Must be root."
	exit 1
fi

# endless loop
while : ; do

# We `set -e' to force exit if we encounter an error.
# This is mainly useful in case we lose our tty (happens when
# an ssh connection breaks, for example), in which case our stdout
# is closed and the `echo' commands in the while loop will silently fail.
# Failure to exit at that moment would lead to an infinite loop.
set -e

cho
echo "$MENU_0_07"
echo "$MENU_1_08"
echo "$MENU_2_09"
echo "$MENU_3_10"
echo "$MENU_4_11"
echo "$MENU_5_12"
echo "$MENU_6_13"
echo
read -p "$ENTER_AN_OPTION" OPCODE
echo

# The scripts we'll call below may return non-zero, don't exit if they do
set +e

# see what the user has chosen
case ${OPCODE} in
0|exit|logout|quit)
        exit
        ;;
1)
        /usr/local/etc/rc.initial.setports
        ;;
2)
        /usr/local/etc/rc.initial.setlanip
        ;;
3)
        /usr/local/etc/rc.initial.password
        ;;
4)
        /usr/local/etc/rc.initial.defaults
        ;;
5)
        /usr/local/etc/rc.initial.halt
        ;;
6)
        /usr/local/etc/rc.initial.reboot
        ;;
7)
        /usr/local/etc/rc.initial.ping
        ;;
8)
        /bin/csh
        ;;
9)
        /usr/local/sbin/pftop
        ;;
10)
	/usr/sbin/tcpdump -s 256 -v -S -l -n -e -ttt -i pflog0
	;;
11)
	/usr/local/etc/rc.reload_all
	;;
12)
	/usr/local/etc/rc.initial.firmware
	;;
13)
	/usr/local/etc/rc.initial.restore
	;;
*)
	;;
esac

/usr/local/etc/rc.initial.banner

done
